---
title: "Advanced TypeScript Patterns for Better Code Quality"
slug: "typescript-advanced-patterns"
publishedAt: "2024-02-22T16:45:00Z"
updatedAt: "2024-02-22T16:45:00Z"
tags: ["typescript", "patterns", "code-quality", "advanced"]
description: "Explore advanced TypeScript patterns and techniques that will help you write more maintainable, type-safe, and robust applications."
emoji: "üîß"
---

# Advanced TypeScript Patterns for Better Code Quality

TypeScript has evolved far beyond simple type annotations. Modern TypeScript offers powerful features that can dramatically improve code quality, maintainability, and developer experience. Let's explore some advanced patterns that every TypeScript developer should know.

## Conditional Types and Type Guards

### Conditional Types

Conditional types allow you to create types that depend on other types:

```typescript
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : T extends number 
  ? { count: T } 
  : { data: T };

// Usage
type StringResponse = ApiResponse<string>; // { message: string }
type NumberResponse = ApiResponse<number>; // { count: number }
type ObjectResponse = ApiResponse<User>;   // { data: User }
```

### Advanced Type Guards

Create sophisticated type guards for runtime type checking:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
}

function isAdmin(user: User | Admin): user is Admin {
  return 'permissions' in user;
}

function handleUser(user: User | Admin) {
  if (isAdmin(user)) {
    // TypeScript knows user is Admin here
    console.log(`Admin with ${user.permissions.length} permissions`);
  } else {
    // TypeScript knows user is User here
    console.log(`Regular user: ${user.name}`);
  }
}
```

## Template Literal Types

Create dynamic string types based on patterns:

```typescript
type EventName<T extends string> = `on${Capitalize<T>}`;
type HttpMethod = 'get' | 'post' | 'put' | 'delete';
type ApiEndpoint<T extends HttpMethod> = `api/${T}`;

// Usage
type ClickHandler = EventName<'click'>; // 'onClick'
type GetEndpoint = ApiEndpoint<'get'>;  // 'api/get'

// Advanced: Extract route parameters
type ExtractParams<T extends string> = 
  T extends `${string}:${infer Param}/${infer Rest}`
    ? { [K in Param]: string } & ExtractParams<Rest>
    : T extends `${string}:${infer Param}`
    ? { [K in Param]: string }
    : {};

type RouteParams = ExtractParams<'/users/:id/posts/:postId'>; 
// { id: string; postId: string }
```

## Utility Types and Mapped Types

### Custom Utility Types

Create reusable utility types for common patterns:

```typescript
// Make specific properties optional
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Make specific properties required
type RequiredBy<T, K extends keyof T> = T & Required<Pick<T, K>>;

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// Usage
interface CreateUserRequest {
  name: string;
  email: string;
  age?: number;
  preferences?: UserPreferences;
}

type UpdateUserRequest = PartialBy<CreateUserRequest, 'name' | 'email'>;
type ImmutableUser = DeepReadonly<User>;
```

### Advanced Mapped Types

```typescript
// Transform all properties to functions
type Functionalize<T> = {
  [K in keyof T]: () => T[K];
};

// Create event handlers for all properties
type EventHandlers<T> = {
  [K in keyof T as `on${Capitalize<string & K>}Change`]: (value: T[K]) => void;
};

interface FormData {
  username: string;
  email: string;
  age: number;
}

type FormHandlers = EventHandlers<FormData>;
// {
//   onUsernameChange: (value: string) => void;
//   onEmailChange: (value: string) => void;
//   onAgeChange: (value: number) => void;
// }
```

## Generic Constraints and Inference

### Advanced Generic Constraints

```typescript
// Constrain generics to have specific properties
interface Identifiable {
  id: string;
}

interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

function updateEntity<T extends Identifiable & Timestamped>(
  entity: T,
  updates: Partial<Omit<T, 'id' | 'createdAt'>>
): T {
  return {
    ...entity,
    ...updates,
    updatedAt: new Date()
  };
}
```

### Infer Keyword Magic

```typescript
// Extract return type from function
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// Extract array element type
type ArrayElement<T> = T extends (infer U)[] ? U : never;

// Extract promise value type
type PromiseValue<T> = T extends Promise<infer U> ? U : never;

// Advanced: Extract function parameters
type Parameters<T extends (...args: any) => any> = 
  T extends (...args: infer P) => any ? P : never;

async function fetchUser(id: string): Promise<User> {
  // implementation
}

type FetchUserParams = Parameters<typeof fetchUser>; // [string]
type FetchUserReturn = PromiseValue<ReturnType<typeof fetchUser>>; // User
```

## Branded Types for Type Safety

Create distinct types that prevent mixing similar values:

```typescript
// Branded type helper
type Brand<T, B> = T & { __brand: B };

// Create branded types
type UserId = Brand<string, 'UserId'>;
type Email = Brand<string, 'Email'>;
type PostId = Brand<string, 'PostId'>;

// Factory functions
function createUserId(id: string): UserId {
  // Add validation here
  return id as UserId;
}

function createEmail(email: string): Email {
  if (!email.includes('@')) {
    throw new Error('Invalid email');
  }
  return email as Email;
}

// Usage prevents mixing types
function getUser(id: UserId): Promise<User> {
  // implementation
}

function sendEmail(to: Email, subject: string): void {
  // implementation
}

const userId = createUserId('user-123');
const email = createEmail('user@example.com');

getUser(userId); // ‚úÖ Correct
// getUser(email); // ‚ùå TypeScript error
```

## Builder Pattern with TypeScript

Create type-safe builders that enforce required properties:

```typescript
interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
  ssl?: boolean;
}

class DatabaseConfigBuilder {
  private config: Partial<DatabaseConfig> = {};

  host(host: string): this {
    this.config.host = host;
    return this;
  }

  port(port: number): this {
    this.config.port = port;
    return this;
  }

  database(database: string): this {
    this.config.database = database;
    return this;
  }

  username(username: string): this {
    this.config.username = username;
    return this;
  }

  password(password: string): this {
    this.config.password = password;
    return this;
  }

  ssl(enabled: boolean): this {
    this.config.ssl = enabled;
    return this;
  }

  build(): DatabaseConfig {
    const required: (keyof DatabaseConfig)[] = ['host', 'port', 'database', 'username', 'password'];
    
    for (const key of required) {
      if (this.config[key] === undefined) {
        throw new Error(`Missing required property: ${key}`);
      }
    }

    return this.config as DatabaseConfig;
  }
}

// Usage
const config = new DatabaseConfigBuilder()
  .host('localhost')
  .port(5432)
  .database('myapp')
  .username('admin')
  .password('secret')
  .ssl(true)
  .build();
```

## Conclusion

These advanced TypeScript patterns provide powerful tools for creating more robust, maintainable applications. By leveraging conditional types, template literals, advanced generics, and branded types, you can catch more errors at compile time and create APIs that are both flexible and type-safe.

Remember that with great power comes great responsibility‚Äîuse these patterns judiciously. Sometimes a simple type annotation is better than a complex generic constraint. The goal is always to make your code more maintainable and your intent clearer to other developers.

Start incorporating these patterns gradually into your codebase, and you'll find that TypeScript becomes an even more powerful ally in building quality software.